<!DOCTYPE HTML>
<!-- Signals to the Layout Dialect which layout should be used to decorate this View -->
<html xmlns:layout="http://www.w3.org/1999/xhtml"
      xmlns:th="http://www.w3.org/1999/xhtml"
      layout:decorate="~{layout}" lang="en">

<!-- <head section> -->
<th:block layout:fragment="head" th:remove="tag">
  <!-- Page specific head additions -->
  <title>Strings Algo</title>
  <!-- Override colors.css -->
</th:block>

<!-- <body> -->
<th:block layout:fragment="body" th:remove="tag">
<!-- Page specific body additions -->
  <div class="container py-4">
    <header class="pb-3 mb-4 border-bottom">
      <h3>Start a new sequence</h3>
      <div class="form-group">
        <input type="text" class="form-control" id="new_sequence" placeholder="enter new sequence">
        <button class="btn btn-primary bg-secondary" onclick="sequence(1);">Restart!</button>
      </div>

      <label></label> <!-spacer->

      <h3>Update</h3>
      <div class="form-group">
        <input type="text" class="form-control" id="update_sequence" th:value="${object}">
        <button class="btn btn-primary bg-secondary" onclick="sequence(2);">Update!</button>
      </div>
    </header>

    <div class="row align-items-md-stretch">

      <div class="h-100 p-5 text-black bg-light rounded-3">
        <!-- Series -->
        <table class="table">
          <thead>
          <tr>
            <th scope="col">Recent sequence of operations</th>
          </tr>
          </thead>
          <tbody id="result">
          <tr th:each="event : ${object.getEvents()}">
            <td th:text="${event}"></td>
          </tr>
          </tbody>
        </table>
      </div>

    </div>

  </div>
  <script>
    function sequence(action) {
      // fetch standard requires data set to a name-value pair
      let sequence = "";
      switch (action) {
        case 1:
          sequence = document.getElementById("new_sequence");
          break;
        case 2:
          sequence = document.getElementById("update_sequence");
          break;
      }
      const body = {
        sequence: sequence.value,
        action: action
      };
      // fetch call with header options
      fetch('/api/strings/', {
        method: "POST",
        credentials: "include",
        body: JSON.stringify(body),
        cache: "no-cache",
        headers: new Headers({
          "content-type": "application/json"
        })
      })
      // async then replies with response header
      .then(function (response) {
        // prepare HTML search result container for new output
        const resultContainer = document.getElementById("result");
        // clean up from previous search
        while (resultContainer.firstChild) {
          resultContainer.removeChild(resultContainer.firstChild);
        }
        // assumption is response contains valid result
        response.json().then(function(result) {
          // loop through JSON and build HTML output
          for (let i = 0; i < result.length; i++) {
            const row = document.createElement("tr");
            row.innerHTML = '<td>' + result[i] + '</td>';
            resultContainer.appendChild(row);
          }
        })
      })
    }
  </script>
</th:block>`

</html>
